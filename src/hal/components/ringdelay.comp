component delay "A delay by means of a circular buffer";
pin in float in "The input value that is to be delayed";
pin out float out "The value of \\fBin\\fR shown after the specified \\fBtime\\fR.";
pin in float time "The delay time of \\fBin\\fR to \\fBout\\fR.";
description """
This component will delay the signal of the \\fBin\\ for a given \\fBtime\\fR
to the signal \\fBout\\fR when the \\fBEN\\fR parameter is \\fB1\\fR.
.LP
When time equals \"0\" then the reading position of the ringbuffer equals the
writing position. Thus \\fBout\\fR equals \\fB\\fR.
.LP
When \\fBtime\\fR is increased, say for ease of understanding that it was
\\fB0\\fR, and is set to \\fB10\\fR periods. The reading position will wait 10
periods (so it is not increased) while the writing position will increase with
each period. If the reading position equals its target delay then it will also
increase with each period.
.LP
When \\fBtime\\fR is decreased, for example: it was \\fB10\\fR, and is set to
\\fB3\\fR periods. The writing position will now wait 7 periods (so it is not
increased) while the reading position will increase with each period until it
has reached the target delay.
.LP
The \\fBtime\\fR must never be greater than the (max size -1) of the ring. and
is then limited to (max size -1)
""";
author "Bas de Bruijn";
license "GPL"; // indicates GPL v2 or later

function _;
;;

option singleton yes;
option rtapi_app no;

license "GPLv2 or later";

;;

#define MAXSIZE 1024

#include "hal_priv.h"
#include "hal_ring.h"	        /* ringbuffer declarations */

static char *ring = "ring_0";
RTAPI_MP_STRING(ring,  "name of ring to attach");

static ringbuffer_t rb;
static ringiter_t ri;


static char buffer[MAXSIZE];
static size_t length;
static char *name = "ringdelay";

FUNCTION(_) {
//from ringwrite----------------------------------------------------------------
    if (write_prev ^  write) {
	rtapi_snprintf(buffer, sizeof(buffer), "message %u to %s, sender=comp %d",
		       sent, ring, comp_id);
	length = strlen(buffer);
	sent++;

	if (rb.header->type == RINGTYPE_STREAM) {
	    if (stream_write(&rb, buffer, length) != length)
		overrun++;
	} else {
	    if (circular) {
		// circular buffer behavior: drop oldest records if full
		while (record_write(&rb, buffer, length) ==  EAGAIN) {
		    dropped++;
		    record_shift(&rb);
		}
	    } else {
		// queue behavior: fail if insufficient space
		if (record_write(&rb, buffer, length))
		    overrun++;
	    }
	}
	write_prev = write;
    }

//from ringread-----------------------------------------------------------------
  ringvec_t vec[2];
  ring_size_t rsize;
  const void *data;

  if (rb.header->type == RINGTYPE_STREAM) {
  // peek into the stream, non-copy mode
  stream_get_read_vector(&rb, vec);
  rsize = vec[0].rv_len + vec[1].rv_len;
  if (vec[0].rv_len) {
    rtapi_print_msg(RTAPI_MSG_ERR, "%s(%s): bytes=%d '%.*s",
        name, ring, rsize,
        (int) vec[0].rv_len, (char *) vec[0].rv_base);
    if (vec[1].rv_len) {
  rtapi_print_msg(RTAPI_MSG_ERR, "%.*s",
      (int) vec[1].rv_len, (char *) vec[1].rv_base);
    }
    rtapi_print_msg(RTAPI_MSG_ERR, "'\n");

    // consume bytes read
    stream_read_advance(&rb, rsize);
    received++;
    // if we have a scratchpad, leave a dropping there
    if (rb.scratchpad) {
  rtapi_snprintf(rb.scratchpad,ring_scratchpad_size(&rb),
           "received=%d underrun=%d",
           received, underrun);
    }
  } else
    underrun++;
  } else {
  if (circular) {
    char buf[MAXSIZE];
    int result;
    size_t size;

    result = record_iter_read(&ri, &data, &size);
    switch (result) {
    case EINVAL:
  // generation changed due to consumer too slow, renew
  tooslow++;
  record_iter_init(&rb, &ri);
  break;
    case EAGAIN:
  // ring empty
  underrun++;
  break;
    default:
  // record available, but commit only after successful iter_shift()
  memcpy(buf, data, size > sizeof(buf) ? sizeof(buf) : size);
  if (record_iter_shift(&ri) == EINVAL) {
      tooslow++;
      break;
  }
  // good to consume buffer
  rtapi_print_msg(RTAPI_MSG_ERR,
      "circular: %s(%s): reclen=%zu '%.*s', writer=%d\n",
      name, ring, size, (int) size, buf,
      rb.header->writer);
  break;
    }
  } else {
    rsize = record_next_size(&rb);
    if (rsize < 0) {
  // ring empty
  underrun++;
  return;
    }
    rtapi_print_msg(RTAPI_MSG_ERR, "%s(%s): reclen=%d '%.*s', writer=%d\n",
        name, ring, rsize, rsize,
        (char *) record_next(&rb),
        rb.header->writer);
    // consume record
    record_shift(&rb);
    received++;
  }
  if (rb.scratchpad) {
    rtapi_snprintf(rb.scratchpad,ring_scratchpad_size(&rb),
       "received=%d underrun=%d",
       received, underrun);
  }
  }
}

FUNCTION(_) {

}



int rtapi_app_main(void)
{
    int retval;

    comp_id = hal_init(name);
    if (comp_id < 0) {
	    rtapi_print_msg(RTAPI_MSG_ERR,
			    "%s: ERROR: hal_init() failed: %d\n",
			    name, comp_id);
	    return -1;
    }
    if ((retval = hal_ring_attach(ring, &rb, NULL))) {
	    rtapi_print_msg(RTAPI_MSG_ERR,
    			"%s: ERROR: hal_ring_attach(%s) failed: %d\n",
    			name, ring, retval);
	    return -1;
    }
    rtapi_print_msg(RTAPI_MSG_INFO,
        "%s: attached ring '%s' size=%zu type=%d"
        " rmutex=%d wmutex=%d reader=%d writer=%d scratchpad=%zu\n",
        name, ring, rb.header->size,
        rb.header->type,
        ring_use_rmutex(&rb), ring_use_wmutex(&rb),
        rb.header->reader, rb.header->writer,
        ring_scratchpad_size(&rb));
    rb.header->reader = comp_id;
    rb.header->reader_instance = rtapi_instance;
    rb.header->writer = comp_id;
    rb.header->writer_instance = rtapi_instance;
    if ((retval = export(name, 0))) {
    	rtapi_print_msg(RTAPI_MSG_ERR,
		  	"%s: ERROR: export(%s) failed: %d\n",
		   	name, name, retval);
	    return -1;
    }
    hal_ready(comp_id);
    rtapi_print_msg(RTAPI_MSG_ERR,
		    "%s: attached to %s reader=%d writer=%d\n",
		    name, ring, rb.header->reader, rb.header->writer);

    record_iter_init(&rb, &ri);
    return 0;
}

void rtapi_app_exit(void)
{
    int retval;
    rb.header->writer = 0;
    if ((retval = hal_ring_detach(ring, &rb)) < 0)
	rtapi_print_msg(RTAPI_MSG_ERR,
			"%s: ERROR: hal_ring_detach(%s) failed: %d\n",
			name, ring, retval);
    hal_exit(comp_id);

    rb.header->reader = 0;
    if ((retval = hal_ring_detach(ring, &rb)) < 0)
  rtapi_print_msg(RTAPI_MSG_ERR,
      "%s: ERROR: hal_ring_detach(%s) failed: %d\n",
      name, ring, retval);
    hal_exit(comp_id);
}
